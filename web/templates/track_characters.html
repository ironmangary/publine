{% extends "base.html" %}
{% block title %}{{ project.title }} - Track Characters for Chapter {{ chapter.number }}{% endblock %}

{% block content %}
<div class="container mt-4">
    <h2>Track Characters (AI) for Chapter {{ chapter.number }}: {{ chapter.title }}</h2>

    {% with messages = get_flashed_messages(with_categories=true) %}
        {% if messages %}
            {% for category, message in messages %}
                <div class="alert alert-{{ category }}">{{ message }}</div>
            {% endfor %}
        {% endif %}
    {% endwith %}

    <div class="card mb-4">
        <div class="card-header">
            <h3>Generate Character Tracking Data</h3>
        </div>
        <div class="card-body">
            <p>Click the button below to use AI to identify characters in this chapter, count their mentions, and determine if it's their first appearance in the story context.</p>
            <form method="POST" action="{{ url_for('chapter_tools_bp.track_characters', slug=project.slug, chapter_num=chapter.number) }}">
                <button type="submit" name="trigger_character_tracking" class="btn btn-success">Track Characters with AI</button>
            </form>
        </div>
    </div>

    {% if characters_data %}
    <div class="card mb-4">
        <div class="card-header">
            <h3>Generated Characters (Review and Edit)</h3>
        </div>
        <div class="card-body">
            <p>Review the generated character data below. You can edit the table directly. Once satisfied, click "Save Character Data".</p>
            
            <form id="saveCharactersForm" method="POST" action="{{ url_for('chapter_tools_bp.track_characters', slug=project.slug, chapter_num=chapter.number) }}">
                <input type="hidden" name="edited_characters_data" id="editedCharactersData">
                <input type="hidden" name="save_characters" value="true">
                
                <div class="table-responsive">
                    <table class="table table-striped table-hover mt-3" id="characterTable">
                        <thead>
                            <tr>
                                <th data-sortable="true" data-sort-key="name">Name</th>
                                <th data-sortable="true" data-sort-key="mentions">Mentions</th>
                                <th data-sortable="false">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for character in characters_data %}
                            <tr data-index="{{ loop.index0 }}">
                                <td contenteditable="true" data-field="name">{{ character.name }}</td>
                                <td contenteditable="true" data-field="mentions" data-type="number">{{ character.mentions }}</td>
                                <td>
                                    <button type="button" class="btn btn-danger btn-sm" onclick="removeCharacterRow(this)">Remove</button>
                                </td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
                <button type="button" class="btn btn-info btn-sm mb-3" onclick="addCharacterRow()">Add New Character</button>
                <button type="submit" class="btn btn-primary mt-3">Save Character Data</button>
            </form>
            <p class="mt-3 text-muted">Data will be saved to: <pre>{{ expected_character_file_relative }}</pre></p>
        </div>
    </div>
    {% endif %}

    <a href="{{ url_for('chapter_tools_bp.chapter_tools_menu', slug=project.slug) }}" class="btn btn-secondary mt-3">Back to Chapter Tools</a>
</div>

<script>
    // Function to collect table data and update hidden input
    function updateCharacterData() {
        const table = document.getElementById('characterTable');
        const rows = table.querySelectorAll('tbody tr');
        const characters = [];

        rows.forEach(row => {
            const name = row.querySelector('[data-field="name"]').innerText.trim();
            const mentions = parseInt(row.querySelector('[data-field="mentions"]').innerText.trim(), 10);

            if (name) { // Only add if name is not empty
                characters.push({
                    name: name,
                    mentions: isNaN(mentions) ? 0 : mentions // Default to 0 if not a number
                });
            }
        });
        document.getElementById('editedCharactersData').value = JSON.stringify(characters);
    }

    // Call on page load and before form submission
    document.addEventListener('DOMContentLoaded', updateCharacterData);
    document.getElementById('saveCharactersForm').addEventListener('submit', updateCharacterData);

    // Client-side row removal
    function removeCharacterRow(button) {
        if (confirm("Are you sure you want to remove this character?")) {
            button.closest('tr').remove();
            updateCharacterData(); // Update data after removal
        }
    }

    // Client-side row addition
    function addCharacterRow() {
        const tableBody = document.querySelector('#characterTable tbody');
        const newRow = tableBody.insertRow();
        newRow.innerHTML = `
            <td contenteditable="true" data-field="name">New Character</td>
            <td contenteditable="true" data-field="mentions" data-type="number">0</td>
            <td>
                <button type="button" class="btn btn-danger btn-sm" onclick="removeCharacterRow(this)">Remove</button>
            </td>
        `;
        updateCharacterData(); // Update data after addition
    }

    // Basic client-side sorting (only for demonstration, can be replaced by a library)
    document.querySelectorAll('[data-sortable="true"]').forEach(header => {
        header.style.cursor = 'pointer';
        header.addEventListener('click', () => {
            const table = header.closest('table');
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            const key = header.getAttribute('data-sort-key');
            let isAsc = header.classList.contains('asc');

            rows.sort((a, b) => {
                let valA, valB;
                const fieldA = a.querySelector(`[data-field="${key}"]`);
                const fieldB = b.querySelector(`[data-field="${key}"]`);

                if (fieldA.getAttribute('data-type') === 'number') {
                    valA = parseInt(fieldA.innerText, 10);
                    valB = parseInt(fieldB.innerText, 10);
                } else {
                    valA = fieldA.innerText.toLowerCase();
                    valB = fieldB.innerText.toLowerCase();
                }

                if (valA < valB) return isAsc ? -1 : 1;
                if (valA > valB) return isAsc ? 1 : -1;
                return 0;
            });

            // Clear previous sort classes
            header.closest('thead').querySelectorAll('th').forEach(th => {
                th.classList.remove('asc', 'desc');
            });

            // Apply new sort class
            header.classList.toggle('asc', !isAsc);
            header.classList.toggle('desc', isAsc);

            rows.forEach(row => tbody.appendChild(row));
        });
    });

</script>
{% endblock %}
